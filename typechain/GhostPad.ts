/* Autogenerated file. Do not edit manually. */
/* tslint:disable */
/* eslint-disable */
import type {
  BaseContract,
  BigNumber,
  BigNumberish,
  BytesLike,
  CallOverrides,
  ContractTransaction,
  Overrides,
  PayableOverrides,
  PopulatedTransaction,
  Signer,
  utils,
} from "ethers";
import type {
  FunctionFragment,
  Result,
  EventFragment,
} from "@ethersproject/abi";
import type { Listener, Provider } from "@ethersproject/providers";
import type {
  TypedEventFilter,
  TypedEvent,
  TypedListener,
  OnEvent,
} from "./common";

export declare namespace GhostPad {
  export type TokenDataStruct = {
    name: string;
    symbol: string;
    initialSupply: BigNumberish;
    description: string;
    taxRate: BigNumberish;
    taxRecipient: string;
    burnEnabled: boolean;
    liquidityLockPeriod: BigNumberish;
  };

  export type TokenDataStructOutput = [
    string,
    string,
    BigNumber,
    string,
    BigNumber,
    string,
    boolean,
    BigNumber
  ] & {
    name: string;
    symbol: string;
    initialSupply: BigNumber;
    description: string;
    taxRate: BigNumber;
    taxRecipient: string;
    burnEnabled: boolean;
    liquidityLockPeriod: BigNumber;
  };

  export type ProofDataStruct = {
    instanceIndex: BigNumberish;
    proof: BytesLike;
    root: BytesLike;
    nullifierHash: BytesLike;
    recipient: string;
    relayer: string;
    fee: BigNumberish;
    refund: BigNumberish;
    metadataProof: BytesLike;
    metadataHash: BytesLike;
  };

  export type ProofDataStructOutput = [
    BigNumber,
    string,
    string,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    string,
    string
  ] & {
    instanceIndex: BigNumber;
    proof: string;
    root: string;
    nullifierHash: string;
    recipient: string;
    relayer: string;
    fee: BigNumber;
    refund: BigNumber;
    metadataProof: string;
    metadataHash: string;
  };
}

export interface GhostPadInterface extends utils.Interface {
  functions: {
    "MAX_GOVERNANCE_FEE()": FunctionFragment;
    "deployToken((string,string,uint256,string,uint256,address,bool,uint256),(uint256,bytes,bytes32,bytes32,address,address,uint256,uint256,bytes,bytes32),bool,bool)": FunctionFragment;
    "deployTokenWithLiquidity((string,string,uint256,string,uint256,address,bool,uint256),(uint256,bytes,bytes32,bytes32,address,address,uint256,uint256,bytes,bytes32),uint256,uint256,bool,bool)": FunctionFragment;
    "deployedTokens(bytes32)": FunctionFragment;
    "getDeployedToken(bytes32)": FunctionFragment;
    "getTornadoInstance(uint256)": FunctionFragment;
    "governance()": FunctionFragment;
    "governanceFee()": FunctionFragment;
    "instanceCount()": FunctionFragment;
    "metadataVerifier()": FunctionFragment;
    "nullifierHashUsed(bytes32)": FunctionFragment;
    "owner()": FunctionFragment;
    "recoverERC20(address,uint256)": FunctionFragment;
    "recoverETH()": FunctionFragment;
    "renounceOwnership()": FunctionFragment;
    "tokenTemplate()": FunctionFragment;
    "tornadoInstances(uint256)": FunctionFragment;
    "transferOwnership(address)": FunctionFragment;
    "uniswapHandler()": FunctionFragment;
    "updateGovernance(address)": FunctionFragment;
    "updateGovernanceFee(uint32)": FunctionFragment;
    "updateMetadataVerifier(address)": FunctionFragment;
    "updateUniswapHandler(address)": FunctionFragment;
  };

  getFunction(
    nameOrSignatureOrTopic:
      | "MAX_GOVERNANCE_FEE"
      | "deployToken"
      | "deployTokenWithLiquidity"
      | "deployedTokens"
      | "getDeployedToken"
      | "getTornadoInstance"
      | "governance"
      | "governanceFee"
      | "instanceCount"
      | "metadataVerifier"
      | "nullifierHashUsed"
      | "owner"
      | "recoverERC20"
      | "recoverETH"
      | "renounceOwnership"
      | "tokenTemplate"
      | "tornadoInstances"
      | "transferOwnership"
      | "uniswapHandler"
      | "updateGovernance"
      | "updateGovernanceFee"
      | "updateMetadataVerifier"
      | "updateUniswapHandler"
  ): FunctionFragment;

  encodeFunctionData(
    functionFragment: "MAX_GOVERNANCE_FEE",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "deployToken",
    values: [
      GhostPad.TokenDataStruct,
      GhostPad.ProofDataStruct,
      boolean,
      boolean
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "deployTokenWithLiquidity",
    values: [
      GhostPad.TokenDataStruct,
      GhostPad.ProofDataStruct,
      BigNumberish,
      BigNumberish,
      boolean,
      boolean
    ]
  ): string;
  encodeFunctionData(
    functionFragment: "deployedTokens",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getDeployedToken",
    values: [BytesLike]
  ): string;
  encodeFunctionData(
    functionFragment: "getTornadoInstance",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "governance",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "governanceFee",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "instanceCount",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "metadataVerifier",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "nullifierHashUsed",
    values: [BytesLike]
  ): string;
  encodeFunctionData(functionFragment: "owner", values?: undefined): string;
  encodeFunctionData(
    functionFragment: "recoverERC20",
    values: [string, BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "recoverETH",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "renounceOwnership",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "tokenTemplate",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "tornadoInstances",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "transferOwnership",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "uniswapHandler",
    values?: undefined
  ): string;
  encodeFunctionData(
    functionFragment: "updateGovernance",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "updateGovernanceFee",
    values: [BigNumberish]
  ): string;
  encodeFunctionData(
    functionFragment: "updateMetadataVerifier",
    values: [string]
  ): string;
  encodeFunctionData(
    functionFragment: "updateUniswapHandler",
    values: [string]
  ): string;

  decodeFunctionResult(
    functionFragment: "MAX_GOVERNANCE_FEE",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployTokenWithLiquidity",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "deployedTokens",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getDeployedToken",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "getTornadoInstance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "governance", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "governanceFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "instanceCount",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "metadataVerifier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "nullifierHashUsed",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "recoverERC20",
    data: BytesLike
  ): Result;
  decodeFunctionResult(functionFragment: "recoverETH", data: BytesLike): Result;
  decodeFunctionResult(
    functionFragment: "renounceOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tokenTemplate",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "tornadoInstances",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "transferOwnership",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "uniswapHandler",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateGovernance",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateGovernanceFee",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateMetadataVerifier",
    data: BytesLike
  ): Result;
  decodeFunctionResult(
    functionFragment: "updateUniswapHandler",
    data: BytesLike
  ): Result;

  events: {
    "GovernanceFeeUpdated(uint32,uint32)": EventFragment;
    "GovernanceUpdated(address,address)": EventFragment;
    "LiquidityPoolCreated(address,address,uint256)": EventFragment;
    "MetadataVerifierUpdated(address,address)": EventFragment;
    "OwnershipTransferred(address,address)": EventFragment;
    "TokenDeployed(bytes32,address,string,string)": EventFragment;
    "UniswapHandlerUpdated(address,address)": EventFragment;
  };

  getEvent(nameOrSignatureOrTopic: "GovernanceFeeUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "GovernanceUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "LiquidityPoolCreated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "MetadataVerifierUpdated"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "OwnershipTransferred"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "TokenDeployed"): EventFragment;
  getEvent(nameOrSignatureOrTopic: "UniswapHandlerUpdated"): EventFragment;
}

export interface GovernanceFeeUpdatedEventObject {
  oldFee: number;
  newFee: number;
}
export type GovernanceFeeUpdatedEvent = TypedEvent<
  [number, number],
  GovernanceFeeUpdatedEventObject
>;

export type GovernanceFeeUpdatedEventFilter =
  TypedEventFilter<GovernanceFeeUpdatedEvent>;

export interface GovernanceUpdatedEventObject {
  oldGovernance: string;
  newGovernance: string;
}
export type GovernanceUpdatedEvent = TypedEvent<
  [string, string],
  GovernanceUpdatedEventObject
>;

export type GovernanceUpdatedEventFilter =
  TypedEventFilter<GovernanceUpdatedEvent>;

export interface LiquidityPoolCreatedEventObject {
  tokenAddress: string;
  pairAddress: string;
  liquidityAdded: BigNumber;
}
export type LiquidityPoolCreatedEvent = TypedEvent<
  [string, string, BigNumber],
  LiquidityPoolCreatedEventObject
>;

export type LiquidityPoolCreatedEventFilter =
  TypedEventFilter<LiquidityPoolCreatedEvent>;

export interface MetadataVerifierUpdatedEventObject {
  oldVerifier: string;
  newVerifier: string;
}
export type MetadataVerifierUpdatedEvent = TypedEvent<
  [string, string],
  MetadataVerifierUpdatedEventObject
>;

export type MetadataVerifierUpdatedEventFilter =
  TypedEventFilter<MetadataVerifierUpdatedEvent>;

export interface OwnershipTransferredEventObject {
  previousOwner: string;
  newOwner: string;
}
export type OwnershipTransferredEvent = TypedEvent<
  [string, string],
  OwnershipTransferredEventObject
>;

export type OwnershipTransferredEventFilter =
  TypedEventFilter<OwnershipTransferredEvent>;

export interface TokenDeployedEventObject {
  nullifierHash: string;
  tokenAddress: string;
  name: string;
  symbol: string;
}
export type TokenDeployedEvent = TypedEvent<
  [string, string, string, string],
  TokenDeployedEventObject
>;

export type TokenDeployedEventFilter = TypedEventFilter<TokenDeployedEvent>;

export interface UniswapHandlerUpdatedEventObject {
  oldHandler: string;
  newHandler: string;
}
export type UniswapHandlerUpdatedEvent = TypedEvent<
  [string, string],
  UniswapHandlerUpdatedEventObject
>;

export type UniswapHandlerUpdatedEventFilter =
  TypedEventFilter<UniswapHandlerUpdatedEvent>;

export interface GhostPad extends BaseContract {
  connect(signerOrProvider: Signer | Provider | string): this;
  attach(addressOrName: string): this;
  deployed(): Promise<this>;

  interface: GhostPadInterface;

  queryFilter<TEvent extends TypedEvent>(
    event: TypedEventFilter<TEvent>,
    fromBlockOrBlockhash?: string | number | undefined,
    toBlock?: string | number | undefined
  ): Promise<Array<TEvent>>;

  listeners<TEvent extends TypedEvent>(
    eventFilter?: TypedEventFilter<TEvent>
  ): Array<TypedListener<TEvent>>;
  listeners(eventName?: string): Array<Listener>;
  removeAllListeners<TEvent extends TypedEvent>(
    eventFilter: TypedEventFilter<TEvent>
  ): this;
  removeAllListeners(eventName?: string): this;
  off: OnEvent<this>;
  on: OnEvent<this>;
  once: OnEvent<this>;
  removeListener: OnEvent<this>;

  functions: {
    MAX_GOVERNANCE_FEE(overrides?: CallOverrides): Promise<[number]>;

    deployToken(
      tokenData: GhostPad.TokenDataStruct,
      proofData: GhostPad.ProofDataStruct,
      useProtocolFee: boolean,
      vestingEnabled: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    deployTokenWithLiquidity(
      tokenData: GhostPad.TokenDataStruct,
      proofData: GhostPad.ProofDataStruct,
      liquidityTokenAmount: BigNumberish,
      liquidityEthAmount: BigNumberish,
      useProtocolFee: boolean,
      vestingEnabled: boolean,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<ContractTransaction>;

    deployedTokens(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getDeployedToken(
      nullifierHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<[string]>;

    getTornadoInstance(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber] & { instance: string; denomination: BigNumber }
    >;

    governance(overrides?: CallOverrides): Promise<[string]>;

    governanceFee(overrides?: CallOverrides): Promise<[number]>;

    instanceCount(overrides?: CallOverrides): Promise<[BigNumber]>;

    metadataVerifier(overrides?: CallOverrides): Promise<[string]>;

    nullifierHashUsed(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<[boolean]>;

    owner(overrides?: CallOverrides): Promise<[string]>;

    recoverERC20(
      token: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    recoverETH(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    tokenTemplate(overrides?: CallOverrides): Promise<[string]>;

    tornadoInstances(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber] & { instance: string; denomination: BigNumber }
    >;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    uniswapHandler(overrides?: CallOverrides): Promise<[string]>;

    updateGovernance(
      _newGovernance: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    updateGovernanceFee(
      _newFee: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    updateMetadataVerifier(
      _newVerifier: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;

    updateUniswapHandler(
      _newHandler: string,
      overrides?: Overrides & { from?: string }
    ): Promise<ContractTransaction>;
  };

  MAX_GOVERNANCE_FEE(overrides?: CallOverrides): Promise<number>;

  deployToken(
    tokenData: GhostPad.TokenDataStruct,
    proofData: GhostPad.ProofDataStruct,
    useProtocolFee: boolean,
    vestingEnabled: boolean,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  deployTokenWithLiquidity(
    tokenData: GhostPad.TokenDataStruct,
    proofData: GhostPad.ProofDataStruct,
    liquidityTokenAmount: BigNumberish,
    liquidityEthAmount: BigNumberish,
    useProtocolFee: boolean,
    vestingEnabled: boolean,
    overrides?: PayableOverrides & { from?: string }
  ): Promise<ContractTransaction>;

  deployedTokens(arg0: BytesLike, overrides?: CallOverrides): Promise<string>;

  getDeployedToken(
    nullifierHash: BytesLike,
    overrides?: CallOverrides
  ): Promise<string>;

  getTornadoInstance(
    index: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [string, BigNumber] & { instance: string; denomination: BigNumber }
  >;

  governance(overrides?: CallOverrides): Promise<string>;

  governanceFee(overrides?: CallOverrides): Promise<number>;

  instanceCount(overrides?: CallOverrides): Promise<BigNumber>;

  metadataVerifier(overrides?: CallOverrides): Promise<string>;

  nullifierHashUsed(
    arg0: BytesLike,
    overrides?: CallOverrides
  ): Promise<boolean>;

  owner(overrides?: CallOverrides): Promise<string>;

  recoverERC20(
    token: string,
    amount: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  recoverETH(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  renounceOwnership(
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  tokenTemplate(overrides?: CallOverrides): Promise<string>;

  tornadoInstances(
    arg0: BigNumberish,
    overrides?: CallOverrides
  ): Promise<
    [string, BigNumber] & { instance: string; denomination: BigNumber }
  >;

  transferOwnership(
    newOwner: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  uniswapHandler(overrides?: CallOverrides): Promise<string>;

  updateGovernance(
    _newGovernance: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  updateGovernanceFee(
    _newFee: BigNumberish,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  updateMetadataVerifier(
    _newVerifier: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  updateUniswapHandler(
    _newHandler: string,
    overrides?: Overrides & { from?: string }
  ): Promise<ContractTransaction>;

  callStatic: {
    MAX_GOVERNANCE_FEE(overrides?: CallOverrides): Promise<number>;

    deployToken(
      tokenData: GhostPad.TokenDataStruct,
      proofData: GhostPad.ProofDataStruct,
      useProtocolFee: boolean,
      vestingEnabled: boolean,
      overrides?: CallOverrides
    ): Promise<string>;

    deployTokenWithLiquidity(
      tokenData: GhostPad.TokenDataStruct,
      proofData: GhostPad.ProofDataStruct,
      liquidityTokenAmount: BigNumberish,
      liquidityEthAmount: BigNumberish,
      useProtocolFee: boolean,
      vestingEnabled: boolean,
      overrides?: CallOverrides
    ): Promise<string>;

    deployedTokens(arg0: BytesLike, overrides?: CallOverrides): Promise<string>;

    getDeployedToken(
      nullifierHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<string>;

    getTornadoInstance(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber] & { instance: string; denomination: BigNumber }
    >;

    governance(overrides?: CallOverrides): Promise<string>;

    governanceFee(overrides?: CallOverrides): Promise<number>;

    instanceCount(overrides?: CallOverrides): Promise<BigNumber>;

    metadataVerifier(overrides?: CallOverrides): Promise<string>;

    nullifierHashUsed(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<boolean>;

    owner(overrides?: CallOverrides): Promise<string>;

    recoverERC20(
      token: string,
      amount: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    recoverETH(overrides?: CallOverrides): Promise<void>;

    renounceOwnership(overrides?: CallOverrides): Promise<void>;

    tokenTemplate(overrides?: CallOverrides): Promise<string>;

    tornadoInstances(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<
      [string, BigNumber] & { instance: string; denomination: BigNumber }
    >;

    transferOwnership(
      newOwner: string,
      overrides?: CallOverrides
    ): Promise<void>;

    uniswapHandler(overrides?: CallOverrides): Promise<string>;

    updateGovernance(
      _newGovernance: string,
      overrides?: CallOverrides
    ): Promise<void>;

    updateGovernanceFee(
      _newFee: BigNumberish,
      overrides?: CallOverrides
    ): Promise<void>;

    updateMetadataVerifier(
      _newVerifier: string,
      overrides?: CallOverrides
    ): Promise<void>;

    updateUniswapHandler(
      _newHandler: string,
      overrides?: CallOverrides
    ): Promise<void>;
  };

  filters: {
    "GovernanceFeeUpdated(uint32,uint32)"(
      oldFee?: null,
      newFee?: null
    ): GovernanceFeeUpdatedEventFilter;
    GovernanceFeeUpdated(
      oldFee?: null,
      newFee?: null
    ): GovernanceFeeUpdatedEventFilter;

    "GovernanceUpdated(address,address)"(
      oldGovernance?: string | null,
      newGovernance?: string | null
    ): GovernanceUpdatedEventFilter;
    GovernanceUpdated(
      oldGovernance?: string | null,
      newGovernance?: string | null
    ): GovernanceUpdatedEventFilter;

    "LiquidityPoolCreated(address,address,uint256)"(
      tokenAddress?: string | null,
      pairAddress?: string | null,
      liquidityAdded?: null
    ): LiquidityPoolCreatedEventFilter;
    LiquidityPoolCreated(
      tokenAddress?: string | null,
      pairAddress?: string | null,
      liquidityAdded?: null
    ): LiquidityPoolCreatedEventFilter;

    "MetadataVerifierUpdated(address,address)"(
      oldVerifier?: string | null,
      newVerifier?: string | null
    ): MetadataVerifierUpdatedEventFilter;
    MetadataVerifierUpdated(
      oldVerifier?: string | null,
      newVerifier?: string | null
    ): MetadataVerifierUpdatedEventFilter;

    "OwnershipTransferred(address,address)"(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;
    OwnershipTransferred(
      previousOwner?: string | null,
      newOwner?: string | null
    ): OwnershipTransferredEventFilter;

    "TokenDeployed(bytes32,address,string,string)"(
      nullifierHash?: BytesLike | null,
      tokenAddress?: null,
      name?: null,
      symbol?: null
    ): TokenDeployedEventFilter;
    TokenDeployed(
      nullifierHash?: BytesLike | null,
      tokenAddress?: null,
      name?: null,
      symbol?: null
    ): TokenDeployedEventFilter;

    "UniswapHandlerUpdated(address,address)"(
      oldHandler?: string | null,
      newHandler?: string | null
    ): UniswapHandlerUpdatedEventFilter;
    UniswapHandlerUpdated(
      oldHandler?: string | null,
      newHandler?: string | null
    ): UniswapHandlerUpdatedEventFilter;
  };

  estimateGas: {
    MAX_GOVERNANCE_FEE(overrides?: CallOverrides): Promise<BigNumber>;

    deployToken(
      tokenData: GhostPad.TokenDataStruct,
      proofData: GhostPad.ProofDataStruct,
      useProtocolFee: boolean,
      vestingEnabled: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    deployTokenWithLiquidity(
      tokenData: GhostPad.TokenDataStruct,
      proofData: GhostPad.ProofDataStruct,
      liquidityTokenAmount: BigNumberish,
      liquidityEthAmount: BigNumberish,
      useProtocolFee: boolean,
      vestingEnabled: boolean,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<BigNumber>;

    deployedTokens(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getDeployedToken(
      nullifierHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    getTornadoInstance(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    governance(overrides?: CallOverrides): Promise<BigNumber>;

    governanceFee(overrides?: CallOverrides): Promise<BigNumber>;

    instanceCount(overrides?: CallOverrides): Promise<BigNumber>;

    metadataVerifier(overrides?: CallOverrides): Promise<BigNumber>;

    nullifierHashUsed(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    owner(overrides?: CallOverrides): Promise<BigNumber>;

    recoverERC20(
      token: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    recoverETH(overrides?: Overrides & { from?: string }): Promise<BigNumber>;

    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    tokenTemplate(overrides?: CallOverrides): Promise<BigNumber>;

    tornadoInstances(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<BigNumber>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    uniswapHandler(overrides?: CallOverrides): Promise<BigNumber>;

    updateGovernance(
      _newGovernance: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    updateGovernanceFee(
      _newFee: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    updateMetadataVerifier(
      _newVerifier: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;

    updateUniswapHandler(
      _newHandler: string,
      overrides?: Overrides & { from?: string }
    ): Promise<BigNumber>;
  };

  populateTransaction: {
    MAX_GOVERNANCE_FEE(
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    deployToken(
      tokenData: GhostPad.TokenDataStruct,
      proofData: GhostPad.ProofDataStruct,
      useProtocolFee: boolean,
      vestingEnabled: boolean,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    deployTokenWithLiquidity(
      tokenData: GhostPad.TokenDataStruct,
      proofData: GhostPad.ProofDataStruct,
      liquidityTokenAmount: BigNumberish,
      liquidityEthAmount: BigNumberish,
      useProtocolFee: boolean,
      vestingEnabled: boolean,
      overrides?: PayableOverrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    deployedTokens(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getDeployedToken(
      nullifierHash: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    getTornadoInstance(
      index: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    governance(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    governanceFee(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    instanceCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    metadataVerifier(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    nullifierHashUsed(
      arg0: BytesLike,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    recoverERC20(
      token: string,
      amount: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    recoverETH(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    renounceOwnership(
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    tokenTemplate(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    tornadoInstances(
      arg0: BigNumberish,
      overrides?: CallOverrides
    ): Promise<PopulatedTransaction>;

    transferOwnership(
      newOwner: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    uniswapHandler(overrides?: CallOverrides): Promise<PopulatedTransaction>;

    updateGovernance(
      _newGovernance: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    updateGovernanceFee(
      _newFee: BigNumberish,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    updateMetadataVerifier(
      _newVerifier: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;

    updateUniswapHandler(
      _newHandler: string,
      overrides?: Overrides & { from?: string }
    ): Promise<PopulatedTransaction>;
  };
}
